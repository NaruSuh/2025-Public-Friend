# 01.01 - Modern Python Development Environment

This guide covers setting up a robust, modern, and efficient development environment for Python projects. This is the bedrock of Vibe Codingâ€”a clean, reproducible, and automated setup frees you to focus on building.

## Core Concepts

1.  **Virtual Environments**: Isolate project dependencies to avoid conflicts.
2.  **Dependency Management**: Define, install, and lock dependencies for reproducibility.
3.  **Code Formatting**: Automatically enforce a consistent code style.
4.  **Linting**: Statically analyze code to find errors, bugs, and stylistic issues.
5.  **Type Checking**: Use type hints to catch errors before runtime and improve code clarity.
6.  **Task Running**: Automate common development tasks (e.g., running tests, formatting).

## Recommended Toolchain

| Category                | Tool                                                                 | Why it's essential for Vibe Coding                               |
| ----------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------- |
| **Virtual Environment** | `venv` (built-in)                                                    | Standard, reliable, and universally available.                   |
| **Dependency Manager**  | `pip` + `pip-tools` (for `pip-compile`)                              | `pip` is the standard. `pip-tools` adds crucial dependency locking. |
| **Code Formatter**      | `black`                                                              | Uncompromisingly enforces a single, clean style. No more debates. |
| **Linter**              | `ruff`                                                               | Extremely fast (written in Rust). Combines many tools (flake8, isort). |
| **Type Checker**        | `mypy`                                                               | The de-facto standard for static type checking in Python.        |
| **Task Runner**         | `Makefile` or `pyproject.toml [tool.scripts]`                        | Simple, effective automation for CLI commands.                   |
| **Project Config**      | `pyproject.toml`                                                     | The modern, standardized way to configure Python projects.       |

---

## Step-by-Step Setup Guide

Let's set up a new project from scratch.

### 1. Project Structure

Create a standard project layout.

```bash
mkdir my-vibe-project
cd my-vibe-project
mkdir src
touch src/main.py
touch .gitignore
```

A good `.gitignore` to start with:
```
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env

# IDE / Editor
.vscode/
.idea/
*.swp
```

### 2. Initialize Virtual Environment

Always start here.

```bash
python3 -m venv .venv
source .venv/bin/activate
```
Your shell prompt should now be prefixed with `(.venv)`.

### 3. Configure `pyproject.toml`

This is your central configuration file. Create `pyproject.toml` in the root.

```toml
[project]
name = "my-vibe-project"
version = "0.1.0"
description = "A project built with the Vibe Coding philosophy."
requires-python = ">=3.10"

[tool.black]
line-length = 88
target-version = ['py310']

[tool.ruff]
line-length = 88
select = ["E", "F", "W", "I", "UP", "C4", "B"] # E/F/W=flake8, I=isort, UP=pyupgrade, C4=flake8-comprehensions, B=flake8-bugbear
ignore = ["E501"] # Let black handle line length

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true
```

### 4. Install and Manage Dependencies with `pip-tools`

Instead of a simple `requirements.txt`, we'll use a two-file system for better control.

1.  **`requirements.in`**: For your direct, high-level dependencies.
2.  **`requirements.txt`**: The "lock file", generated by `pip-compile`, with pinned versions of all dependencies and sub-dependencies.

First, install `pip-tools`:
```bash
pip install pip-tools
```

Create `requirements.in` for your main dependencies and `dev-requirements.in` for development tools.

**`requirements.in`**:
```
# Application dependencies
fastapi
uvicorn[standard]
pydantic
```

**`dev-requirements.in`**:
```
# Development tools
-c requirements.txt  # Constrain dev tools to versions used by the app
black
ruff
mypy
pytest
```

Now, compile them:
```bash
pip-compile requirements.in -o requirements.txt
pip-compile dev-requirements.in -o dev-requirements.txt
```

You'll see `requirements.txt` and `dev-requirements.txt` are generated with pinned versions. This is **critical for reproducibility**.

Install everything:
```bash
pip install -r requirements.txt
pip install -r dev-requirements.txt
```

### 5. Automate with a `Makefile`

A `Makefile` simplifies running common commands. Create a file named `Makefile`.

```makefile
.PHONY: help install format lint check test

# Colors for output
GREEN := \033[0;32m
RESET := \033[0m

help:
	@echo "Available commands:"
	@echo "  ${GREEN}install${RESET} - Install dependencies"
	@echo "  ${GREEN}format${RESET}  - Format code with black and ruff"
	@echo "  ${GREEN}lint${RESET}    - Lint code with ruff"
	@echo "  ${GREEN}check${RESET}   - Run static type checking with mypy"
	@echo "  ${GREEN}test${RESET}    - Run tests with pytest"
	@echo "  ${GREEN}all${RESET}     - Run format, lint, check, and test"

install:
	@echo "--> Installing dependencies..."
	@pip install -r requirements.txt
	@pip install -r dev-requirements.txt

format:
	@echo "--> Formatting code..."
	@ruff --fix .
	@black .

lint:
	@echo "--> Linting code..."
	@ruff .

check:
	@echo "--> Running type checks..."
	@mypy src

test:
	@echo "--> Running tests..."
	@pytest

all: format lint check test
```

Now you can simply run `make format`, `make lint`, etc.

## Vibe Coding Workflow

Your daily workflow becomes a simple, powerful loop:

1.  **Code**: Write your feature in `src/`.
2.  **Test**: Write a corresponding test.
3.  **Automate Checks**: Run `make all`. This command will format, lint, type-check, and run tests in one go.
4.  **Commit**: Once all checks pass, commit your code.
5.  **Update Dependencies**:
    -   Add a new package to `requirements.in`.
    -   Run `pip-compile requirements.in -o requirements.txt`.
    -   Run `pip install -r requirements.txt`.
    -   Commit the updated `.in` and `.txt` files.

This disciplined approach minimizes bugs, ensures consistency, and makes your project a joy to work on, whether solo or with a team. It is the foundation upon which scalable, reliable systems are built.
